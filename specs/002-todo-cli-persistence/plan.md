# Implementation Plan: Todo CLI with File-Based Persistence

**Branch**: `002-todo-cli-persistence` | **Date**: 2025-12-29 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/002-todo-cli-persistence/spec.md`

## Summary

Implement a command-line Todo application with five core operations (add, list, update, delete, mark complete/incomplete) that persist tasks across CLI sessions using JSON file storage. Tasks are stored at `~/.todo/tasks.json` (configurable via `TODO_FILE` environment variable), loaded on CLI startup, and saved immediately after each mutation. The application uses Python 3.13+ with Click framework for CLI, follows TDD principles, and implements all 38 functional requirements from the specification.

## Technical Context

**Language/Version**: Python 3.13+ (per constitution Technology Stack)
**Primary Dependencies**: `click` (CLI framework), `json` (stdlib), `pathlib` (stdlib), `dataclasses` (stdlib)
**Storage**: JSON file at `~/.todo/tasks.json` (configurable via `TODO_FILE` environment variable)
**Testing**: `pytest` with `pytest-cov` for coverage, `tempfile` for persistence tests
**Target Platform**: Cross-platform CLI (Linux, macOS, Windows)
**Project Type**: Single project (CLI application)
**Performance Goals**: <5s task add (SC-001), <2s list for up to 1000 tasks (SC-003)
**Constraints**: No external databases, no network connections, JSON file only, <100ms file I/O
**Scale/Scope**: Single user, ~1000 tasks max, 5 CLI commands, <1MB storage file

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Evidence |
|-----------|--------|----------|
| I. Spec-First Development | PASS | Spec complete at `spec.md` with 38 FRs, 5 user stories, 12 success criteria |
| II. CLI-First Interface | PASS | All operations via CLI subcommands, stdout/stderr separation, `--help` support |
| III. Test-Driven Development | PLANNED | Tests will be written before implementation per tasks |
| IV. JSON File Persistence | PASS | JSON storage at ~/.todo/tasks.json, configurable via TODO_FILE, auto-save on mutations |
| V. Clean Code & Simplicity | PLANNED | Single project structure, stdlib-only for persistence (json, pathlib) |
| VI. Auditability & Traceability | PASS | PHRs created, spec traceability maintained, constitution v1.1.0 compliance |

**Gate Result**: PASS - Proceed to Phase 0

## Project Structure

### Documentation (this feature)

```text
specs/002-todo-cli-persistence/
├── plan.md              # This file
├── research.md          # Phase 0: Technology decisions and best practices
├── data-model.md        # Phase 1: Task entity and JSON schema
├── quickstart.md        # Phase 1: User getting started guide
├── contracts/           # Phase 1: CLI command contracts
│   └── cli-contract.md
├── checklists/
│   └── requirements.md  # Spec quality validation
└── tasks.md             # Phase 2: Implementation tasks (generated by /sp.tasks)
```

### Source Code (repository root)

```text
src/
├── __init__.py
├── models/
│   ├── __init__.py
│   └── task.py          # Task dataclass with JSON serialization support
├── services/
│   ├── __init__.py
│   └── task_service.py  # Business logic (CRUD + persistence layer)
├── cli/
│   ├── __init__.py
│   └── main.py          # Click CLI entry point
└── lib/
    ├── __init__.py
    ├── validators.py    # Input validation (title, description length)
    └── storage.py       # JSON file I/O operations (load/save)

tests/
├── __init__.py
├── conftest.py          # Shared fixtures (temp storage paths, service instances)
├── unit/
│   ├── __init__.py
│   ├── test_task.py             # Task model tests
│   ├── test_task_service.py     # Service CRUD tests
│   ├── test_storage.py          # JSON persistence tests
│   └── test_validators.py       # Validation logic tests
└── integration/
    ├── __init__.py
    └── test_cli.py      # End-to-end CLI command tests with persistence
```

**Structure Decision**: Single project structure selected (per constitution V. Clean Code & Simplicity). CLI application with clear separation of concerns: models (data), services (business logic + persistence), cli (interface), lib (utilities). Tests mirror source structure with unit and integration levels.

## Complexity Tracking

> No violations - all design decisions comply with constitution principles.

| Aspect | Decision | Rationale |
|--------|----------|-----------|
| CLI Framework | `click` over `argparse` | Better subcommand support, auto-help generation, less boilerplate (per constitution) |
| Storage | JSON file | Meets constitution IV requirement, human-readable, stdlib support, no external deps |
| In-Memory Cache | `dict[int, Task]` | O(1) lookup by ID, simple iteration for list operations |
| ID Generation | Sequential counter (persisted) | Simple, unique, survives restarts, meets FR-003 & FR-013 |
| Save Strategy | Auto-save on mutations | Immediate persistence ensures FR-009, no explicit save command needed |
| File I/O | Separate `storage.py` module | Single responsibility, testable in isolation, reusable |

## Key Design Decisions

### CLI Command Structure

Using Click's command group pattern with subcommands:

```bash
todo add "Buy groceries" --description "From the farmers market"
todo list
todo complete 1
todo incomplete 1
todo update 1 --title "Buy organic groceries"
todo delete 1
```

**Rationale**: Industry standard CLI pattern, familiar to users, clear command semantics

### Task Storage Architecture

```
TaskService
    ├── _tasks: dict[int, Task]      # ID → Task mapping (in-memory cache)
    ├── _next_id: int                # Auto-incrementing counter
    ├── _storage_path: Path          # JSON file location
    └── Methods:
        ├── __init__()               # Load from JSON on startup
        ├── _load()                  # Read tasks from JSON file
        ├── _save()                  # Write tasks to JSON file (auto-called on mutations)
        ├── add/update/delete/mark   # CRUD operations (auto-save after each)
        └── list_all/get             # Read-only operations (no save)
```

**JSON File Format**:
```json
{
  "next_id": 4,
  "tasks": [
    {
      "id": 1,
      "title": "Buy groceries",
      "description": "From farmers market",
      "status": "incomplete"
    },
    {
      "id": 2,
      "title": "Call dentist",
      "description": "",
      "status": "complete"
    }
  ]
}
```

**Storage Flow**:
1. CLI startup → TaskService.__init__() → _load() reads JSON
2. User command (e.g., `todo add`) → TaskService method → mutation + _save()
3. CLI exit → File already saved, no cleanup needed

### Error Handling Strategy

- **Validation Errors**: Caught at input (validators.py), raise ValueError with clear messages
- **File I/O Errors**: Caught at storage layer (storage.py), display clear error with guidance
- **Corrupted JSON**: Log warning to stderr, start with empty task list
- **CLI Errors**: Caught at CLI layer (main.py), output to stderr with exit code 1

**Error Message Pattern**: Always include actionable guidance (e.g., "Check file permissions")

## Dependencies

### Runtime Dependencies

| Package | Version | Purpose | Constitution Justification |
|---------|---------|---------|---------------------------|
| click | ^8.0 | CLI framework | Explicit option in constitution Technology Stack |
| Python | 3.13+ | Runtime | Per constitution Technology Stack requirement |

**Note**: All persistence functionality uses Python stdlib (json, pathlib, os, dataclasses)

### Development Dependencies

| Package | Version | Purpose |
|---------|---------|---------|
| pytest | ^8.0 | Testing framework |
| pytest-cov | ^4.0 | Coverage reporting |
| ruff | ^0.8 | Linting |
| black | ^24.0 | Code formatting |

## Risk Analysis

| Risk | Impact | Mitigation |
|------|--------|------------|
| Corrupted JSON file | Medium | Graceful fallback to empty task list, log warning, preserve original file |
| File permission errors | Medium | Clear error messages with actionable guidance, validate permissions early |
| Concurrent CLI instances | Low | Last-write-wins behavior, documented in spec assumptions |
| Large JSON files (>1000 tasks) | Low | Performance goals accommodate up to 1000 tasks per SC-003 |
| Disk full during save | Medium | Error message displayed, in-memory state preserved, user can retry |
| Manual JSON edits breaking format | Low | Validation on load, graceful degradation, clear warnings |

## Implementation Phases

This plan generates the following artifacts:

**Phase 0 (Complete)**: ✅
- `research.md`: Technology decisions and best practices

**Phase 1 (Complete)**: ✅
- `data-model.md`: Task entity and JSON schema
- `contracts/cli-contract.md`: CLI command specifications
- `quickstart.md`: User getting started guide
- Agent context updated with project technologies

**Phase 2 (Next Step)**:
- Run `/sp.tasks` to generate `tasks.md` with implementation tasks
- Tasks will be ordered by priority and dependencies
- Each task will include test cases derived from acceptance scenarios

## Post-Design Constitution Check

*Re-evaluating constitution compliance after design decisions:*

| Principle | Status | Evidence |
|-----------|--------|----------|
| I. Spec-First Development | PASS | All design derived from spec.md (38 FRs, 5 user stories, 12 SCs) |
| II. CLI-First Interface | PASS | Click framework selected, all commands defined in contracts, stdout/stderr separation |
| III. Test-Driven Development | READY | Testing strategy defined in research.md, test structure in project layout |
| IV. JSON File Persistence | PASS | Storage architecture documented, auto-save strategy, ~/.todo/tasks.json default |
| V. Clean Code & Simplicity | PASS | Single project, stdlib for persistence, clear module separation, no unnecessary abstractions |
| VI. Auditability & Traceability | PASS | PHRs maintained, all design decisions documented with rationale |

**Gate Result**: PASS - Ready for Phase 2 task generation

## Next Steps

1. **Generate Tasks**: Run `/sp.tasks` to create `tasks.md` with:
   - Test-first implementation tasks (Red-Green-Refactor cycles)
   - Priority ordering based on user story priorities
   - Dependencies between tasks clearly marked
   - Acceptance criteria from spec mapped to test cases

2. **Begin Implementation**: Follow TDD workflow:
   - Write failing tests (Red)
   - Implement minimum code to pass (Green)
   - Refactor while keeping tests green (Refactor)
   - Update task status as work completes

3. **Validation**: After implementation:
   - Run `/sp.analyze` to verify spec-plan-tasks-code consistency
   - Suggest ADRs if architecturally significant decisions made
   - Prepare for hackathon judge review
